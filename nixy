#!/usr/bin/env bash
#
# nixy - Homebrew-style wrapper for Nix using flake.nix
#

set -euo pipefail

# Configuration
NIXY_CONFIG_DIR="${NIXY_CONFIG_DIR:-$HOME/.config/nix}"
NIXY_PROFILE="${NIXY_PROFILE:-}"
GLOBAL_FLAKE="$NIXY_CONFIG_DIR/flake.nix"
LOCAL_PACKAGES_DIR="${NIXY_CONFIG_DIR}/packages"
NIX_FLAGS=(--extra-experimental-features nix-command --extra-experimental-features flakes)

# Version info
NIXY_VERSION="0.1.17"
NIXY_REPO_URL="https://raw.githubusercontent.com/yusukeshib/nixy/main/nixy"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helpers
info() { echo -e "${BLUE}==>>${NC} $*"; }
success() { echo -e "${GREEN}==>>${NC} $*"; }
warn() { echo -e "${YELLOW}Warning:${NC} $*"; }
error() { echo -e "${RED}Error:${NC} $*" >&2; }
die() { error "$@"; exit 1; }

# Get profile flags for nix profile commands
get_profile_flags() {
    if [[ -n "$NIXY_PROFILE" ]]; then
        echo "--profile" "$NIXY_PROFILE"
    fi
}

# Check dependencies
check_deps() {
    command -v nix >/dev/null 2>&1 || die "nix is not installed"
}

# Search up directory tree for flake.nix
find_local_flake() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/flake.nix" ]]; then
            echo "$dir/flake.nix"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

# Get the flake.nix path (local takes precedence over global)
get_flake() {
    local use_global="${1:-false}"

    if [[ "$use_global" == "true" ]]; then
        echo "$GLOBAL_FLAKE"
        return 0
    fi

    # Search up directory tree for local flake
    local local_flake
    if local_flake=$(find_local_flake); then
        echo "$local_flake"
        return 0
    fi

    # No local flake found and --global not specified
    die "No flake.nix found in current directory or parents. Use --global for global flake."
}

# Get flake directory (resolves symlinks)
get_flake_dir() {
    local use_global="${1:-false}"
    local flake
    flake="$(get_flake "$use_global")" || exit 1
    # Resolve symlinks to get real path
    if [[ -L "$flake" ]]; then
        local target
        target="$(readlink "$flake")"
        # If target is relative, resolve it relative to the symlink's directory
        if [[ "$target" != /* ]]; then
            target="$(dirname "$flake")/$target"
        fi
        # Normalize and return the directory
        (cd "$(dirname "$target")" && pwd)
    else
        dirname "$flake"
    fi
}

# Check if flake.nix is managed by nixy (has markers)
is_nixy_managed_flake() {
    local flake="$1"
    [[ -f "$flake" ]] && grep -q '\[nixy:packages\]' "$flake"
}

# Parse packages from flake.nix (profile packages)
get_packages_from_flake() {
    local flake="$1"
    if [[ -f "$flake" ]]; then
        # Extract package names from the packages section (format: "name = pkgs.name;")
        {
            sed -n '/# \[nixy:packages\]/,/# \[\/nixy:packages\]/p' "$flake" 2>/dev/null | \
                { grep -E '^\s+[a-zA-Z0-9_-]+ = pkgs\.' || true; } | \
                sed 's/^[[:space:]]*\([a-zA-Z0-9_-]*\) = pkgs\..*/\1/'
            # Also extract local package names (format: "name = <expr>;")
            sed -n '/# \[nixy:local-packages\]/,/# \[\/nixy:local-packages\]/p' "$flake" 2>/dev/null | \
                { grep -E '^\s+[a-zA-Z0-9_-]+ = ' || true; } | \
                sed 's/^[[:space:]]*\([a-zA-Z0-9_-]*\) = .*/\1/'
        } | sort -u
    fi
}

# Parse only local packages from flake.nix (installed via --file)
get_local_packages_from_flake() {
    local flake="$1"
    if [[ -f "$flake" ]]; then
        sed -n '/# \[nixy:local-packages\]/,/# \[\/nixy:local-packages\]/p' "$flake" 2>/dev/null | \
            { grep -E '^\s+[a-zA-Z0-9_-]+ = ' || true; } | \
            sed 's/^[[:space:]]*\([a-zA-Z0-9_-]*\) = .*/\1/' | \
            sort -u
    fi
}

# Parse dev packages from flake.nix
get_dev_packages_from_flake() {
    local flake="$1"
    if [[ -f "$flake" ]]; then
        # Extract package names from buildInputs
        sed -n '/# \[nixy:devShell\]/,/# \[\/nixy:devShell\]/p' "$flake" 2>/dev/null | \
            { grep -E '^\s+pkgs\.' || true; } | \
            sed 's/.*pkgs\.\([a-zA-Z0-9_-]*\).*/\1/' | \
            sort -u
    fi
}

# Validate that a package exists in nixpkgs and is a derivation
validate_package() {
    local pkg="$1"
    # Check if the package attribute exists and is a derivation
    if ! nix "${NIX_FLAGS[@]}" eval "nixpkgs#$pkg.type" 2>/dev/null | grep -q "derivation"; then
        return 1
    fi
    return 0
}

# Check if a file is a flake (has inputs and outputs)
is_flake_file() {
    local file="$1"
    # A flake file has both 'inputs' and 'outputs' at the top level
    grep -q '^[[:space:]]*inputs[[:space:]]*=' "$file" 2>/dev/null && \
    grep -q '^[[:space:]]*outputs[[:space:]]*=' "$file" 2>/dev/null
}

# Get list of installed packages from nix profile
# Extracts package name from "Flake attribute:" line (e.g., "legacyPackages.aarch64-darwin.fzf" -> "fzf")
# This works for both nixpkgs packages and local flake packages
get_installed_packages() {
    nix "${NIX_FLAGS[@]}" profile list $(get_profile_flags) 2>/dev/null | \
        { grep "^Flake attribute:" || true; } | \
        sed 's/Flake attribute:[[:space:]]*//' | \
        sed 's/.*\.//' | \
        sort -u
}

# Check if nixy-env (buildEnv) is installed
is_nixy_env_installed() {
    nix "${NIX_FLAGS[@]}" profile list $(get_profile_flags) 2>/dev/null | \
        grep -q "nixy-env"
}

# Get the profile element name for nixy-env (for use with nix profile upgrade)
get_nixy_env_name() {
    nix "${NIX_FLAGS[@]}" profile list --json $(get_profile_flags) 2>/dev/null | \
        grep -o '"[^"]*":{"active":true,"attrPath":"packages\.[^"]*\.default"' | \
        head -1 | sed 's/^"\([^"]*\)".*/\1/'
}

# Check if migration from individual packages to buildEnv is needed
needs_migration() {
    local profile_list
    profile_list=$(nix "${NIX_FLAGS[@]}" profile list $(get_profile_flags) 2>/dev/null)
    # Migration needed if we have nixpkgs# packages but no nixy-env
    echo "$profile_list" | grep -q "nixpkgs#" && \
        ! echo "$profile_list" | grep -q "nixy-env"
}

# Migrate from individual packages to buildEnv
migrate_to_buildenv() {
    local flake_dir="$1"
    info "Migrating from individual packages to atomic environment..."

    # Remove all individually installed packages
    local pkgs
    pkgs=$(nix "${NIX_FLAGS[@]}" profile list $(get_profile_flags) 2>/dev/null | \
        { grep "^Flake attribute:" || true; } | \
        sed 's/Flake attribute:[[:space:]]*//' | \
        sed 's/.*\.//')

    for pkg in $pkgs; do
        nix "${NIX_FLAGS[@]}" profile remove $(get_profile_flags) "$pkg" 2>/dev/null || true
    done

    info "Installing unified environment..."
    nix "${NIX_FLAGS[@]}" profile install $(get_profile_flags) "$flake_dir#default"
}

# Install a package and track in flake.nix
cmd_install() {
    local pkg=""
    local file=""
    local use_global=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global|-g) use_global=true; shift ;;
            --file|-f) file="$2"; shift 2 ;;
            *) pkg="$1"; shift ;;
        esac
    done

    if [[ -n "$file" ]]; then
        cmd_install_from_file "$file" "$use_global"
        return
    fi

    [[ -z "$pkg" ]] && die "Usage: nixy install [--global] <package> or nixy install --file <path>"

    # Validate package exists in nixpkgs
    info "Validating package $pkg..."
    if ! validate_package "$pkg"; then
        die "Package '$pkg' not found in nixpkgs or is not a valid derivation. Use 'nixy search <query>' to find packages."
    fi

    # Check if existing flake.nix is nixy-managed before installing
    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy. Use 'nixy init' in a different directory or backup your flake.nix first."
    fi

    # Add package to flake.nix
    add_package_to_flake "$pkg" "$use_global"

    # Only sync for global installs (local packages are used via nixy shell)
    if [[ "$use_global" == "true" ]]; then
        info "Installing $pkg..."
        cmd_sync --global
    else
        info "Added $pkg to flake.nix (use 'nixy shell' to enter dev environment)"
    fi
}

# Parse a local package nix file and extract attributes
parse_local_package() {
    local file="$1"
    local attr="$2"
    # Extract attribute value from nix file format: name = "value"; or name = value;
    # First try quoted values, then unquoted
    local result
    result=$(grep -E "^[[:space:]]*$attr[[:space:]]*=" "$file" | head -1 | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/')
    if [[ "$result" == *"="* ]]; then
        # Fallback for unquoted values
        result=$(grep -E "^[[:space:]]*$attr[[:space:]]*=" "$file" | head -1 | sed 's/.*=[[:space:]]*\([^;]*\);.*/\1/' | tr -d ' ')
    fi
    echo "$result"
}

# Install a package from a local nix file
cmd_install_from_file() {
    local file="$1"
    local use_global="${2:-false}"

    # Validate file exists
    [[ ! -f "$file" ]] && die "File not found: $file"

    # Check if this is a flake file (has inputs and outputs)
    if is_flake_file "$file"; then
        cmd_install_from_flake_file "$file" "$use_global"
        return
    fi

    # Extract package name from file (try 'pname' first, then 'name' for nixpkgs compatibility)
    local pkg_name
    pkg_name=$(parse_local_package "$file" "pname")
    [[ -z "$pkg_name" ]] && pkg_name=$(parse_local_package "$file" "name")
    [[ -z "$pkg_name" ]] && die "Could not find 'name' or 'pname' attribute in $file"

    info "Installing local package: $pkg_name from $file"

    # Get flake directory first (packages must be relative to flake for git tracking)
    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy. Use 'nixy init' in a different directory or backup your flake.nix first."
    fi

    # Create packages directory inside flake directory
    local pkg_dir
    pkg_dir=$(get_packages_dir "$flake_dir")
    mkdir -p "$pkg_dir"

    # Copy file to packages directory
    local dest="$pkg_dir/$pkg_name.nix"
    cp "$file" "$dest"
    success "Copied package definition to $dest"

    # Add the package file to git if the flake directory is a git repo
    if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
        git -C "$flake_dir" add "packages/$pkg_name.nix" 2>/dev/null || true
    fi

    # Regenerate flake.nix preserving existing packages
    local -a packages=()
    while IFS= read -r p; do
        [[ -n "$p" ]] && packages+=("$p")
    done < <(get_packages_from_flake "$flake")

    if [[ "$use_global" == "true" ]]; then
        generate_flake --flake-dir "$flake_dir" --global "${packages[@]+"${packages[@]}"}" > "$flake"
    else
        generate_flake --flake-dir "$flake_dir" "${packages[@]+"${packages[@]}"}" > "$flake"
    fi

    # Only sync for global installs (local packages are used via nixy shell)
    if [[ "$use_global" == "true" ]]; then
        info "Installing $pkg_name..."
        cmd_sync --global
    else
        info "Added $pkg_name to flake.nix (use 'nixy shell' to enter dev environment)"
    fi
}

# Install a package from a local flake file
cmd_install_from_flake_file() {
    local file="$1"
    local use_global="${2:-false}"

    # Extract package name from filename (remove .nix extension and path)
    local pkg_name
    pkg_name=$(basename "$file" .nix)
    # Sanitize: replace non-alphanumeric chars with dashes
    pkg_name=$(echo "$pkg_name" | tr -cs 'a-zA-Z0-9-' '-' | sed 's/^-//;s/-$//')
    [[ -z "$pkg_name" ]] && die "Could not determine package name from filename: $file"

    info "Installing local flake: $pkg_name from $file"

    # Get flake directory first (packages must be relative to flake for git tracking)
    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy. Use 'nixy init' in a different directory or backup your flake.nix first."
    fi

    # Create packages/pkg_name directory for the flake (nix requires flakes to be in a directory)
    local pkg_dir
    pkg_dir=$(get_packages_dir "$flake_dir")
    local flake_pkg_dir="$pkg_dir/$pkg_name"
    mkdir -p "$flake_pkg_dir"

    # Copy file as flake.nix inside the package directory
    local dest="$flake_pkg_dir/flake.nix"
    cp "$file" "$dest"
    success "Copied flake to $dest"

    # Add the flake file to git if the flake directory is a git repo
    if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
        git -C "$flake_dir" add "packages/$pkg_name/flake.nix" 2>/dev/null || true
    fi

    # Regenerate flake.nix preserving existing packages
    local -a packages=()
    while IFS= read -r p; do
        [[ -n "$p" ]] && packages+=("$p")
    done < <(get_packages_from_flake "$flake")

    if [[ "$use_global" == "true" ]]; then
        generate_flake --flake-dir "$flake_dir" --global "${packages[@]+"${packages[@]}"}" > "$flake"
    else
        generate_flake --flake-dir "$flake_dir" "${packages[@]+"${packages[@]}"}" > "$flake"
    fi

    # Only sync for global installs (local packages are used via nixy shell)
    if [[ "$use_global" == "true" ]]; then
        info "Installing $pkg_name..."
        cmd_sync --global
    else
        info "Added $pkg_name to flake.nix (use 'nixy shell' to enter dev environment)"
    fi
}

# Uninstall a package
cmd_uninstall() {
    local use_global=false
    local pkg=""

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global|-g) use_global=true; shift ;;
            *) pkg="$1"; shift ;;
        esac
    done

    [[ -z "$pkg" ]] && die "Usage: nixy uninstall [--global] <package>"

    # Check if existing flake.nix is nixy-managed before uninstalling
    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    info "Uninstalling $pkg..."

    # Remove local package file or flake directory (if exists)
    local pkg_dir
    pkg_dir=$(get_packages_dir "$flake_dir")
    local local_pkg_file="$pkg_dir/$pkg.nix"
    local local_flake_dir="$pkg_dir/$pkg"
    if [[ -f "$local_pkg_file" ]]; then
        info "Removing local package definition: $local_pkg_file"
        rm "$local_pkg_file"
        if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
            git -C "$flake_dir" rm --cached "packages/$pkg.nix" 2>/dev/null || true
        fi
    elif [[ -d "$local_flake_dir" && -f "$local_flake_dir/flake.nix" ]]; then
        info "Removing local flake: $local_flake_dir"
        rm -rf "$local_flake_dir"
        if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
            git -C "$flake_dir" rm -r --cached "packages/$pkg" 2>/dev/null || true
        fi
    fi

    # Remove from flake.nix (source of truth)
    remove_package_from_flake "$pkg" "$use_global"

    # For global uninstalls, rebuild the environment
    if [[ "$use_global" == "true" ]]; then
        info "Rebuilding environment..."
        cmd_sync --global
    else
        success "Removed $pkg from flake.nix"
    fi
}

# Search for packages
cmd_search() {
    local query="$1"
    [[ -z "$query" ]] && die "Usage: nixy search <query>"

    info "Searching for $query..."
    nix "${NIX_FLAGS[@]}" search nixpkgs "$query"
}

# List installed packages
cmd_list() {
    local use_global=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global|-g) use_global=true; shift ;;
            *) shift ;;
        esac
    done

    # Validate flake exists (to give helpful error message)
    get_flake "$use_global" >/dev/null || exit 1

    info "Installed packages:"
    nix "${NIX_FLAGS[@]}" profile list $(get_profile_flags)
}

# Upgrade all packages
cmd_upgrade() {
    local use_global=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global|-g) use_global=true; shift ;;
            *) shift ;;
        esac
    done

    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    # Update flake.lock if flake.nix exists
    if [[ -f "$flake" ]]; then
        info "Updating flake.lock..."
        nix "${NIX_FLAGS[@]}" flake update --flake "$flake_dir"
    fi

    info "Upgrading all packages..."
    nix "${NIX_FLAGS[@]}" profile upgrade $(get_profile_flags) --all
    success "All packages upgraded"
}

# Garbage collect old generations
cmd_gc() {
    info "Running garbage collection..."
    nix-collect-garbage -d
    success "Garbage collection complete"
}

# Get packages directory for a given flake directory
get_packages_dir() {
    local flake_dir="$1"
    echo "$flake_dir/packages"
}

# Collect local packages info
# Sets arrays: LOCAL_PKG_NAMES, LOCAL_PKG_INPUTS, LOCAL_PKG_OVERLAYS, LOCAL_PKG_EXPRS
# Also sets: LOCAL_FLAKE_NAMES (for flake-type packages in subdirectories)
# Takes optional packages_dir argument (defaults to LOCAL_PACKAGES_DIR for backwards compat)
collect_local_packages() {
    local packages_dir="${1:-$LOCAL_PACKAGES_DIR}"
    LOCAL_PKG_NAMES=()
    LOCAL_PKG_INPUTS=()
    LOCAL_PKG_OVERLAYS=()
    LOCAL_PKG_EXPRS=()
    LOCAL_FLAKE_NAMES=()

    [[ ! -d "$packages_dir" ]] && return

    # First, scan for flake directories (subdirectories with flake.nix)
    for flake_dir in "$packages_dir"/*/; do
        [[ ! -d "$flake_dir" ]] && continue
        local flake_file="$flake_dir/flake.nix"
        [[ ! -f "$flake_file" ]] && continue

        # Get the directory name as the package name
        local name
        name=$(basename "$flake_dir")
        LOCAL_FLAKE_NAMES+=("$name")
    done

    # Then, scan for regular .nix files
    for pkg_file in "$packages_dir"/*.nix; do
        [[ ! -f "$pkg_file" ]] && continue

        local name input_name input_url overlay pkg_expr

        # Try 'pname' first (nixpkgs standard), then fall back to 'name'
        name=$(parse_local_package "$pkg_file" "pname")
        [[ -z "$name" ]] && name=$(parse_local_package "$pkg_file" "name")
        [[ -z "$name" ]] && continue

        # Parse inputs block - extract input name and url (handles multiline)
        # Format: inputs = { \n  name.url = "url"; \n };
        # Look for lines containing .url = within the inputs block
        input_name=$(grep '\.url[[:space:]]*=' "$pkg_file" 2>/dev/null | head -1 | sed 's/^[[:space:]]*\([a-zA-Z0-9_-]*\)\.url.*/\1/' || true)
        input_url=$(grep '\.url[[:space:]]*=' "$pkg_file" 2>/dev/null | head -1 | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/' || true)

        overlay=$(parse_local_package "$pkg_file" "overlay")
        pkg_expr=$(parse_local_package "$pkg_file" "packageExpr")

        # If no packageExpr, assume nixpkgs-style derivation and use callPackage
        if [[ -z "$pkg_expr" ]]; then
            pkg_expr="pkgs.callPackage ./packages/$name.nix {}"
        fi

        LOCAL_PKG_NAMES+=("$name")
        LOCAL_PKG_INPUTS+=("$input_name|$input_url")
        LOCAL_PKG_OVERLAYS+=("$overlay")
        LOCAL_PKG_EXPRS+=("$pkg_expr")
    done
}

# Generate flake.nix content
# Usage: generate_flake [--flake-dir <dir>] [--global] [package1] [package2] ...
generate_flake() {
    local flake_dir=""
    local is_global=false
    local -a packages=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --flake-dir)
                flake_dir="$2"
                shift 2
                ;;
            --global)
                is_global=true
                shift
                ;;
            *)
                packages+=("$1")
                shift
                ;;
        esac
    done

    local pkg_entries=""
    local shell_entries=""

    # Determine packages directory
    local packages_dir="$LOCAL_PACKAGES_DIR"
    if [[ -n "$flake_dir" ]]; then
        packages_dir=$(get_packages_dir "$flake_dir")
    fi

    # Filter out local packages (including flake packages) from standard packages list
    collect_local_packages "$packages_dir"
    local -a filtered_packages=()
    for pkg in "${packages[@]+"${packages[@]}"}"; do
        [[ -z "$pkg" ]] && continue
        local is_local=false
        # Check against regular local packages
        for local_name in "${LOCAL_PKG_NAMES[@]+"${LOCAL_PKG_NAMES[@]}"}"; do
            if [[ "$pkg" == "$local_name" ]]; then
                is_local=true
                break
            fi
        done
        # Check against flake packages
        if [[ "$is_local" == "false" ]]; then
            for flake_name in "${LOCAL_FLAKE_NAMES[@]+"${LOCAL_FLAKE_NAMES[@]}"}"; do
                if [[ "$pkg" == "$flake_name" ]]; then
                    is_local=true
                    break
                fi
            done
        fi
        if [[ "$is_local" == "false" ]]; then
            filtered_packages+=("$pkg")
        fi
    done

    for pkg in "${filtered_packages[@]+"${filtered_packages[@]}"}"; do
        [[ -z "$pkg" ]] && continue
        pkg_entries+="          $pkg = pkgs.$pkg;"$'\n'
        shell_entries+="              pkgs.$pkg"$'\n'
    done

    # Build local inputs section
    local local_inputs=""
    local local_input_params=""
    local local_overlays=""
    local local_packages=""

    # Handle flake-type packages (subdirectories with flake.nix)
    if [[ ${#LOCAL_FLAKE_NAMES[@]} -gt 0 ]]; then
        for name in "${LOCAL_FLAKE_NAMES[@]}"; do
            local_inputs+="    $name.url = \"path:./packages/$name\";"$'\n'
            local_input_params+="$name, "
            # Use inputs.$name to avoid shadowing in rec block
            local_packages+="          $name = inputs.$name.packages.\${system}.default;"$'\n'
            shell_entries+="              inputs.$name.packages.\${system}.default"$'\n'
        done
    fi

    # Handle regular local packages (.nix files)
    if [[ ${#LOCAL_PKG_NAMES[@]} -gt 0 ]]; then
        for i in "${!LOCAL_PKG_NAMES[@]}"; do
            local name="${LOCAL_PKG_NAMES[$i]}"
            local input_info="${LOCAL_PKG_INPUTS[$i]}"
            local overlay="${LOCAL_PKG_OVERLAYS[$i]}"
            local pkg_expr="${LOCAL_PKG_EXPRS[$i]}"

            local input_name="${input_info%%|*}"
            local input_url="${input_info##*|}"

            if [[ -n "$input_name" && -n "$input_url" ]]; then
                local_inputs+="    $input_name.url = \"$input_url\";"$'\n'
                local_input_params+="$input_name, "
            fi

            if [[ -n "$overlay" ]]; then
                local_overlays+="          $overlay"$'\n'
            fi

            if [[ -n "$pkg_expr" ]]; then
                local_packages+="          $name = $pkg_expr;"$'\n'
                shell_entries+="              $pkg_expr"$'\n'
            fi
        done
    fi

    # Build buildEnv paths array (for atomic install)
    # Use package names to reference attributes in the rec set
    local buildenv_paths=""
    for pkg in "${filtered_packages[@]+"${filtered_packages[@]}"}"; do
        [[ -z "$pkg" ]] && continue
        buildenv_paths+="              $pkg"$'\n'
    done

    # Add local package names to buildenv paths (reference by name, not expression)
    if [[ ${#LOCAL_PKG_NAMES[@]} -gt 0 ]]; then
        for name in "${LOCAL_PKG_NAMES[@]}"; do
            buildenv_paths+="              $name"$'\n'
        done
    fi

    # Add flake-type package names to buildenv paths
    if [[ ${#LOCAL_FLAKE_NAMES[@]} -gt 0 ]]; then
        for name in "${LOCAL_FLAKE_NAMES[@]}"; do
            buildenv_paths+="              $name"$'\n'
        done
    fi

    # Build outputs function parameters
    local output_params="self, nixpkgs"
    if [[ -n "$local_input_params" ]]; then
        output_params="self, nixpkgs, ${local_input_params%, }"
    fi

    # Build overlays array
    local overlays_content=""
    if [[ -n "$local_overlays" ]]; then
        overlays_content="overlays = [
          # [nixy:local-overlays]
${local_overlays}          # [/nixy:local-overlays]
        ];"
    fi

    # Determine pkgs definition based on whether we have overlays
    local pkgs_def
    if [[ -n "$local_overlays" ]]; then
        pkgs_def="pkgsFor = system: import nixpkgs {
        inherit system;
        $overlays_content
      };
"
    else
        pkgs_def=""
    fi

    local pkgs_binding
    if [[ -n "$local_overlays" ]]; then
        pkgs_binding="let pkgs = pkgsFor system;"
    else
        pkgs_binding="let pkgs = nixpkgs.legacyPackages.\${system};"
    fi

    # Build devShells section (only for project flakes, not global)
    local dev_shells_section=""
    if [[ "$is_global" != "true" ]]; then
        dev_shells_section="
      # Development shell (nixy shell)
      devShells = forAllSystems (system:
        $pkgs_binding
        in {
          default = pkgs.mkShell {
            buildInputs = [
              # [nixy:devShell]
${shell_entries}              # [/nixy:devShell]
            ];
          };
        });"
    fi

    cat << EOF
{
  description = "nixy managed packages";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    # [nixy:local-inputs]
${local_inputs}    # [/nixy:local-inputs]
  };

  outputs = { $output_params }@inputs:
    let
      systems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
      forAllSystems = f: nixpkgs.lib.genAttrs systems (system: f system);
      $pkgs_def
    in {
      # Profile packages (nixy install)
      packages = forAllSystems (system:
        $pkgs_binding
        in rec {
          # [nixy:packages]
${pkg_entries}          # [/nixy:packages]
          # [nixy:local-packages]
${local_packages}          # [/nixy:local-packages]

          # Unified environment for atomic install (nixy sync)
          default = pkgs.buildEnv {
            name = "nixy-env";
            paths = [
              # [nixy:env-paths]
${buildenv_paths}              # [/nixy:env-paths]
            ];
            extraOutputsToInstall = [ "man" "doc" "info" ];
          };
        });$dev_shells_section
    };
}
EOF
}

# Sync installed packages with flake.nix (atomic mode using buildEnv)
cmd_sync() {
    local use_global=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global|-g) use_global=true; shift ;;
            --remove|-r) shift ;; # Kept for backward compatibility (no-op in atomic mode)
            *) shift ;;
        esac
    done

    # Sync only works in global mode
    if [[ "$use_global" != "true" ]]; then
        die "sync only works with --global flag. Use 'nixy sync --global' to sync global packages."
    fi

    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    if [[ ! -f "$flake" ]]; then
        die "No flake.nix found at $flake. Run 'nixy install <package>' to create one."
    fi

    info "Syncing packages with $flake..."

    # Check if flake has buildEnv default output (upgrade from old nixy version)
    if ! nix "${NIX_FLAGS[@]}" eval "$flake_dir#default" &>/dev/null; then
        info "Upgrading flake.nix to buildEnv format..."
        local -a packages=()
        while IFS= read -r p; do
            [[ -n "$p" ]] && packages+=("$p")
        done < <(get_packages_from_flake "$flake")
        generate_flake --flake-dir "$flake_dir" --global "${packages[@]+"${packages[@]}"}" > "$flake"
    fi

    # Check if migration from individual packages is needed
    if needs_migration; then
        warn "Migrating from individual packages to atomic environment..."
        migrate_to_buildenv "$flake_dir"
        success "Sync complete (migrated to atomic mode)"
        return 0
    fi

    # Atomic sync using buildEnv
    if is_nixy_env_installed; then
        local env_name
        env_name=$(get_nixy_env_name)
        if [[ -n "$env_name" ]]; then
            info "Upgrading nixy environment..."
            nix "${NIX_FLAGS[@]}" profile upgrade $(get_profile_flags) "$env_name" || \
                die "Failed to upgrade environment"
        else
            # Fallback: reinstall if can't find the profile name
            info "Reinstalling nixy environment..."
            nix "${NIX_FLAGS[@]}" profile install $(get_profile_flags) "$flake_dir#default" || \
                die "Failed to install environment"
        fi
    else
        info "Installing nixy environment..."
        nix "${NIX_FLAGS[@]}" profile install $(get_profile_flags) "$flake_dir#default" || \
            die "Failed to install environment"
    fi

    success "Sync complete"
}

# Add a package to flake.nix (reads existing packages and adds the new one)
add_package_to_flake() {
    local pkg="$1"
    local use_global="${2:-false}"
    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy. Use 'nixy init' in a different directory or backup your flake.nix first."
    fi

    # Get existing packages from flake
    local -a packages=()
    while IFS= read -r p; do
        [[ -n "$p" ]] && packages+=("$p")
    done < <(get_packages_from_flake "$flake")

    # Add the new package if not already present
    local already_in_flake=false
    for p in "${packages[@]+"${packages[@]}"}"; do
        if [[ "$p" == "$pkg" ]]; then
            already_in_flake=true
            break
        fi
    done

    if [[ "$already_in_flake" == "false" ]]; then
        packages+=("$pkg")
    fi

    # Generate and write flake.nix
    mkdir -p "$flake_dir"
    if [[ "$use_global" == "true" ]]; then
        generate_flake --flake-dir "$flake_dir" --global "${packages[@]}" > "$flake"
    else
        generate_flake --flake-dir "$flake_dir" "${packages[@]}" > "$flake"
    fi
    success "Added $pkg to $flake"
}

# Remove a package from flake.nix
remove_package_from_flake() {
    local pkg="$1"
    local use_global="${2:-false}"
    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    # Get existing packages from flake, excluding the one to remove
    local -a packages=()
    while IFS= read -r p; do
        [[ -n "$p" && "$p" != "$pkg" ]] && packages+=("$p")
    done < <(get_packages_from_flake "$flake")

    # Generate and write flake.nix
    if [[ "$use_global" == "true" ]]; then
        generate_flake --flake-dir "$flake_dir" --global "${packages[@]+"${packages[@]}"}" > "$flake"
    else
        generate_flake --flake-dir "$flake_dir" "${packages[@]+"${packages[@]}"}" > "$flake"
    fi
    success "Removed $pkg from $flake"
}

# Bundle dump - export ALL installed packages to flake.nix (use with --global)
cmd_bundle_dump() {
    local use_global="${1:-false}"
    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy. Use 'nixy init' in a different directory or backup your flake.nix first."
    fi

    info "Dumping installed packages to $flake..."

    # Ensure directory exists
    mkdir -p "$flake_dir"

    # Get installed packages
    local -a packages=()
    while IFS= read -r pkg; do
        [[ -n "$pkg" ]] && packages+=("$pkg")
    done < <(get_installed_packages)

    if [[ ${#packages[@]} -eq 0 ]]; then
        warn "No packages installed"
    fi

    # Generate and write flake.nix
    if [[ "$use_global" == "true" ]]; then
        generate_flake --flake-dir "$flake_dir" --global "${packages[@]}" > "$flake"
    else
        generate_flake --flake-dir "$flake_dir" "${packages[@]}" > "$flake"
    fi

    success "Dumped ${#packages[@]} package(s) to $flake"
    info "Run 'cd $flake_dir && git init && git add flake.nix' to track with git"
}

# Enter dev shell
cmd_shell() {
    local use_global=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global|-g) use_global=true; shift ;;
            *) shift ;;
        esac
    done

    local flake_dir
    flake_dir=$(get_flake_dir "$use_global") || exit 1
    local flake="$flake_dir/flake.nix"

    if [[ ! -f "$flake" ]]; then
        die "No flake.nix found at $flake. Run 'nixy add <package>' to create one."
    fi

    info "Entering dev shell..."
    nix "${NIX_FLAGS[@]}" develop "$flake_dir" --impure --command "$SHELL"
}

# Initialize a local flake.nix
cmd_init() {
    local dir="${1:-.}"
    local flake="$dir/flake.nix"

    [[ -f "$flake" ]] && die "flake.nix already exists at $flake"

    mkdir -p "$dir"
    info "Initializing flake.nix at $flake..."
    generate_flake --flake-dir "$dir" > "$flake"
    success "Created $flake"
}

# Self-upgrade nixy to latest version
cmd_self_upgrade() {
    local force=false
    local dry_run=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            --dry-run) dry_run=true; shift ;;
            *) die "Unknown option: $1. Usage: nixy self-upgrade [--force]" ;;
        esac
    done

    # Dry run mode - just validate args and exit
    if [[ "$dry_run" == "true" ]]; then
        return 0
    fi

    # Get the path to the current script
    local self_path
    self_path="$(realpath "${BASH_SOURCE[0]}")"
    local self_dir
    self_dir="$(dirname "$self_path")"

    # Check write permissions
    if [[ ! -w "$self_dir" ]]; then
        die "No write permission to $self_dir. Try: sudo nixy self-upgrade"
    fi

    info "Checking for updates..."

    # Download latest version to temp file
    local tmp_file
    tmp_file="$(mktemp)"
    trap 'rm -f "$tmp_file"' EXIT

    if ! curl -fsSL "$NIXY_REPO_URL" -o "$tmp_file" 2>/dev/null; then
        die "Failed to download latest version. Check your network connection."
    fi

    # Validate downloaded file (check shebang)
    local first_line
    first_line="$(head -n 1 "$tmp_file")"
    if [[ "$first_line" != "#!/usr/bin/env bash" ]]; then
        die "Downloaded file is invalid (unexpected content)"
    fi

    # Extract remote version
    local remote_version
    remote_version="$(grep -E '^NIXY_VERSION=' "$tmp_file" | head -1 | sed 's/NIXY_VERSION="\([^"]*\)"/\1/')"
    if [[ -z "$remote_version" ]]; then
        die "Could not determine remote version"
    fi

    info "Current version: $NIXY_VERSION"
    info "Latest version:  $remote_version"

    # Compare versions
    if [[ "$NIXY_VERSION" == "$remote_version" ]] && [[ "$force" != "true" ]]; then
        success "Already up to date!"
        rm -f "$tmp_file"
        trap - EXIT
        return 0
    fi

    if [[ "$force" == "true" ]] && [[ "$NIXY_VERSION" == "$remote_version" ]]; then
        info "Forcing reinstall of same version..."
    fi

    # Create backup
    local backup_path="${self_path}.backup"
    info "Creating backup at $backup_path..."
    cp "$self_path" "$backup_path"

    # Get current permissions
    local perms
    perms="$(stat -f '%A' "$self_path" 2>/dev/null || stat -c '%a' "$self_path" 2>/dev/null)"

    # Replace executable
    if ! mv "$tmp_file" "$self_path"; then
        error "Failed to update nixy"
        info "Restoring from backup..."
        mv "$backup_path" "$self_path"
        die "Update failed. Original version restored."
    fi

    # Restore permissions
    chmod "$perms" "$self_path"

    # Clean up backup on success
    rm -f "$backup_path"

    # Clear the trap since tmp_file was moved, not deleted
    trap - EXIT

    success "Successfully upgraded to version $remote_version!"
}

# Show version
cmd_version() {
    echo "nixy version $NIXY_VERSION"
}

# Show help
cmd_help() {
    cat << 'EOF'
nixy - Homebrew-style wrapper for Nix (using flake.nix)

USAGE:
    nixy <command> [args]

BASIC COMMANDS:
    init [dir]              Initialize a local flake.nix (default: current dir)
    install <pkg>           Install a package (tracked in flake.nix)
    install --file <path>   Install from local nix file
    uninstall <pkg>         Uninstall a package
    search <query>          Search for packages
    list                    List installed packages
    upgrade                 Upgrade all packages
    version                 Show nixy version

SYNC COMMANDS:
    sync [--remove]         Sync installed packages with flake.nix
                            (--remove to also remove packages not in flake)

ENVIRONMENT COMMANDS:
    shell                   Enter dev shell from flake.nix
    gc                      Garbage collect old generations

MAINTENANCE COMMANDS:
    self-upgrade [--force]  Upgrade nixy to the latest version

GLOBAL FLAGS:
    --global, -g            Use global flake (~/.config/nix/flake.nix)
                            instead of searching for local flake.nix

CONFIG FILES:
    Global: ~/.config/nix/flake.nix (use with --global)
    Local:  ./flake.nix or parent directories (auto-discovered)
    Local packages: ~/.config/nix/packages/

LOCAL PACKAGE FORMAT:
    {
      name = "my-package";
      inputs = { overlay-name.url = "github:user/repo"; };
      overlay = "overlay-name.overlays.default";
      packageExpr = "pkgs.my-package";
    }

EXAMPLES:
    nixy init                           # Initialize flake.nix in current dir
    nixy install ripgrep                # Install package (uses local flake)
    nixy install --global ripgrep       # Install to global flake
    nixy install --file neovim.nix      # Install from local nix file
    nixy sync                           # Install from flake.nix (on new machine)
    nixy shell                          # Enter dev shell
    nixy version                        # Show current version
    nixy self-upgrade                   # Upgrade to latest version

EOF
}

# Main entry point
main() {
    check_deps

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        init)
            cmd_init "${1:-.}"
            ;;
        install|add)
            cmd_install "$@"
            ;;
        uninstall|remove)
            cmd_uninstall "$@"
            ;;
        search)
            cmd_search "${1:-}"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        gc)
            cmd_gc
            ;;
        shell|dev)
            cmd_shell "$@"
            ;;
        sync)
            cmd_sync "$@"
            ;;
        self-upgrade)
            cmd_self_upgrade "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            die "Unknown command: $cmd. Run 'nixy help' for usage."
            ;;
    esac
}

main "$@"
