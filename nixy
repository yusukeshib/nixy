#!/usr/bin/env bash
#
# nixy - Homebrew-style wrapper for Nix using flake.nix
#

set -euo pipefail

# Configuration
NIXY_CONFIG_DIR="${NIXY_CONFIG_DIR:-$HOME/.config/nixy}"
NIXY_ENV="${NIXY_ENV:-$HOME/.local/state/nixy/env}"
NIXY_PROFILES_DIR="$NIXY_CONFIG_DIR/profiles"
NIXY_ACTIVE_FILE="$NIXY_CONFIG_DIR/active"
NIXY_DEFAULT_PROFILE="default"
GLOBAL_FLAKE="$NIXY_CONFIG_DIR/flake.nix"
NIX_FLAGS=(--extra-experimental-features nix-command --extra-experimental-features flakes)

# Version info
NIXY_VERSION="0.1.31"
NIXY_REPO_URL="https://raw.githubusercontent.com/yusukeshib/nixy/main/nixy"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helpers
info() { echo -e "${BLUE}==>>${NC} $*"; }
success() { echo -e "${GREEN}==>>${NC} $*"; }
warn() { echo -e "${YELLOW}Warning:${NC} $*"; }
error() { echo -e "${RED}Error:${NC} $*" >&2; }
die() { error "$@"; exit 1; }

# Profile management helpers
# Get active profile name (returns default if not set)
get_active_profile() {
    if [[ -f "$NIXY_ACTIVE_FILE" ]]; then
        cat "$NIXY_ACTIVE_FILE"
    else
        echo "$NIXY_DEFAULT_PROFILE"
    fi
}

# Set active profile
set_active_profile() {
    local name="$1"
    mkdir -p "$NIXY_CONFIG_DIR"
    echo "$name" > "$NIXY_ACTIVE_FILE"
}

# Get profile directory path
get_profile_dir() {
    local name="${1:-$(get_active_profile)}"
    echo "$NIXY_PROFILES_DIR/$name"
}

# Check if profile exists
profile_exists() {
    local name="$1"
    [[ -d "$(get_profile_dir "$name")" ]]
}

# Validate profile name (alphanumeric, dashes, underscores only)
validate_profile_name() {
    local name="$1"
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        die "Invalid profile name '$name'. Use only letters, numbers, dashes, and underscores."
    fi
}

# Check if nixy environment symlink exists
is_nixy_env_linked() {
    [[ -L "$NIXY_ENV" ]]
}

# Check dependencies
check_deps() {
    command -v nix >/dev/null 2>&1 || die "nix is not installed"
}

# Get the flake.nix path for the active profile
get_flake() {
    # Default: use active profile's flake (with fallback to legacy location for default profile only)
    local profile_dir active_profile
    active_profile=$(get_active_profile)
    profile_dir=$(get_profile_dir)
    if [[ -f "$profile_dir/flake.nix" ]]; then
        echo "$profile_dir/flake.nix"
    elif [[ "$active_profile" == "$NIXY_DEFAULT_PROFILE" ]] && [[ -f "$GLOBAL_FLAKE" ]]; then
        # Legacy fallback: only for default profile
        echo "$GLOBAL_FLAKE"
    else
        # New installation or non-default profile: use profile directory
        echo "$profile_dir/flake.nix"
    fi
}

# Get flake directory (resolves symlinks)
get_flake_dir() {
    local flake
    flake="$(get_flake)" || exit 1
    # Resolve symlinks to get real path
    if [[ -L "$flake" ]]; then
        local target
        target="$(readlink "$flake")"
        # If target is relative, resolve it relative to the symlink's directory
        if [[ "$target" != /* ]]; then
            target="$(dirname "$flake")/$target"
        fi
        # Normalize and return the directory
        (cd "$(dirname "$target")" && pwd)
    else
        dirname "$flake"
    fi
}

# Check if flake.nix is managed by nixy (has markers)
is_nixy_managed_flake() {
    local flake="$1"
    [[ -f "$flake" ]] && grep -q '\[nixy:packages\]' "$flake"
}

# Insert a line after a marker in a file
# Usage: insert_after_marker <file> <marker_pattern> <line_to_insert>
# Note: marker_pattern is a regex pattern, line_to_insert is literal text
# Uses sed -i.bak for macOS/Linux compatibility
insert_after_marker() {
    local file="$1"
    local marker="$2"
    local line="$3"

    # Escape special characters in the replacement line for sed
    local escaped_line
    escaped_line=$(printf '%s\n' "$line" | sed 's/[&/\]/\\&/g')

    sed -i.bak "/$marker/a\\
$escaped_line" "$file" && rm -f "$file.bak"
}

# Extract content between markers
# Usage: extract_marker_content <file> <marker_name>
# Returns the lines between the markers (excluding the markers themselves)
# Example: extract_marker_content flake.nix "nixy:custom-inputs"
extract_marker_content() {
    local file="$1"
    local marker="$2"

    if [[ ! -f "$file" ]]; then
        return
    fi

    sed -n "/# \[$marker\]/,/# \[\/$marker\]/p" "$file" 2>/dev/null | \
        grep -v "# \[$marker\]" | \
        grep -v "# \[/$marker\]" || true
}

# Check if flake has custom modifications outside nixy markers
# Returns 0 if modifications exist, 1 otherwise
has_custom_modifications() {
    local flake="$1"

    [[ ! -f "$flake" ]] && return 1

    # Generate a clean flake with the same packages
    local -a packages=()
    while IFS= read -r p; do
        [[ -n "$p" ]] && packages+=("$p")
    done < <(get_packages_from_flake "$flake")

    local flake_dir
    flake_dir=$(dirname "$flake")

    # Generate what a clean flake would look like, preserving custom marker content
    local clean_flake
    clean_flake=$(generate_flake --flake-dir "$flake_dir" --preserve-from "$flake" "${packages[@]+"${packages[@]}"}")

    # Compare the actual flake with what we would generate
    local actual_flake
    actual_flake=$(cat "$flake")

    if [[ "$clean_flake" != "$actual_flake" ]]; then
        return 0  # Has modifications
    fi

    return 1  # No modifications
}

# Remove a line matching a pattern from between two markers
# Usage: remove_line_from_section <file> <start_marker> <end_marker> <pattern>
# Note: start_marker and end_marker are literal strings (matched with index())
#       pattern is a regex pattern (matched with ~)
remove_line_from_section() {
    local file="$1"
    local start_marker="$2"
    local end_marker="$3"
    local pattern="$4"

    # Create a temp file for the result
    local tmp_file
    tmp_file=$(mktemp)

    # Use awk to remove matching lines only within the section
    # Using index() for markers (exact string match) to avoid escape sequence issues
    awk -v start="$start_marker" -v end="$end_marker" -v pat="$pattern" '
        index($0, start) > 0 { in_section=1 }
        index($0, end) > 0 { in_section=0 }
        in_section && $0 ~ pat { next }
        { print }
    ' "$file" > "$tmp_file" && command mv "$tmp_file" "$file"
}

# Get current system for nix eval
nix_system() {
    nix "${NIX_FLAGS[@]}" eval --impure --expr 'builtins.currentSystem' --raw 2>/dev/null
}

# Parse packages from flake.nix (profile packages)
# Uses nix eval for reliable parsing (handles special characters correctly)
get_packages_from_flake() {
    local flake="$1"
    local flake_dir
    flake_dir=$(dirname "$flake")

    # flake.lock がなければ空を返す（まだ nix flake update していない）
    [[ -f "$flake_dir/flake.lock" ]] || return 0

    # nix eval でパッケージ名を取得（default を除外、改行区切りで出力）
    nix "${NIX_FLAGS[@]}" eval "$flake_dir#packages.$(nix_system)" \
        --apply 'pkgs: builtins.concatStringsSep "\n" (builtins.filter (n: n != "default") (builtins.attrNames pkgs))' \
        --raw 2>/dev/null || true
}

# Validate that a package exists in nixpkgs and is a derivation
validate_package() {
    local pkg="$1"
    # Check if the package attribute exists and is a derivation
    if ! nix "${NIX_FLAGS[@]}" eval "nixpkgs#$pkg.type" 2>/dev/null | grep -q "derivation"; then
        return 1
    fi
    return 0
}

# Check if a file is a flake (has inputs and outputs)
is_flake_file() {
    local file="$1"
    # A flake file has both 'inputs' and 'outputs' at the top level
    grep -q '^[[:space:]]*inputs[[:space:]]*=' "$file" 2>/dev/null && \
    grep -q '^[[:space:]]*outputs[[:space:]]*=' "$file" 2>/dev/null
}

# Get top-level flake inputs from flake.lock
# Returns input names one per line
get_flake_inputs() {
    local lock_file="$1"
    [[ ! -f "$lock_file" ]] && return 1
    # Parse flake.lock JSON to get root input names
    nix "${NIX_FLAGS[@]}" eval --impure --expr "builtins.attrNames (builtins.fromJSON (builtins.readFile \"$lock_file\")).nodes.root.inputs" \
        --apply 'names: builtins.concatStringsSep "\n" names' \
        --raw 2>/dev/null || return 1
}

# Validate that input names exist in flake.lock
# Returns 0 if all inputs valid, 1 otherwise
# Sets INVALID_INPUTS array with invalid input names
validate_flake_inputs() {
    local lock_file="$1"
    shift
    local -a inputs=("$@")

    INVALID_INPUTS=()
    local valid_inputs
    valid_inputs=$(get_flake_inputs "$lock_file") || return 1

    for input in "${inputs[@]}"; do
        if ! echo "$valid_inputs" | grep -qx "$input"; then
            INVALID_INPUTS+=("$input")
        fi
    done

    [[ ${#INVALID_INPUTS[@]} -eq 0 ]]
}


# Install a package and track in flake.nix
cmd_install() {
    local pkg=""
    local file=""
    local force=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --file|-f) file="$2"; shift 2 ;;
            --force) force=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) pkg="$1"; shift ;;
        esac
    done

    if [[ -n "$file" ]]; then
        cmd_install_from_file "$file" "$force"
        return
    fi

    [[ -z "$pkg" ]] && die "Usage: nixy install <package> or nixy install --file <path>"

    # Validate package exists in nixpkgs
    info "Validating package $pkg..."
    if ! validate_package "$pkg"; then
        die "Package '$pkg' not found in nixpkgs or is not a valid derivation. Use 'nixy search <query>' to find packages."
    fi

    # Check if existing flake.nix is nixy-managed before installing
    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    # Add package to flake.nix
    add_package_to_flake "$pkg"

    info "Installing $pkg..."
    cmd_sync
}

# Parse a local package nix file and extract attributes
parse_local_package() {
    local file="$1"
    local attr="$2"
    # Extract attribute value from nix file format: name = "value"; or name = value;
    # First try quoted values, then unquoted
    local result
    result=$(grep -E "^[[:space:]]*$attr[[:space:]]*=" "$file" | head -1 | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/')
    if [[ "$result" == *"="* ]]; then
        # Fallback for unquoted values
        result=$(grep -E "^[[:space:]]*$attr[[:space:]]*=" "$file" | head -1 | sed 's/.*=[[:space:]]*\([^;]*\);.*/\1/' | tr -d ' ')
    fi
    echo "$result"
}

# Install a package from a local nix file
cmd_install_from_file() {
    local file="$1"
    local force="${2:-false}"

    # Validate file exists
    [[ ! -f "$file" ]] && die "File not found: $file"

    # Check if this is a flake file (has inputs and outputs)
    if is_flake_file "$file"; then
        cmd_install_from_flake_file "$file" "$force"
        return
    fi

    # Extract package name from file (try 'pname' first, then 'name' for nixpkgs compatibility)
    local pkg_name
    pkg_name=$(parse_local_package "$file" "pname")
    [[ -z "$pkg_name" ]] && pkg_name=$(parse_local_package "$file" "name")
    [[ -z "$pkg_name" ]] && die "Could not find 'name' or 'pname' attribute in $file"

    info "Installing local package: $pkg_name from $file"

    # Get flake directory first (packages must be relative to flake for git tracking)
    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    # Check for custom modifications outside markers BEFORE making any changes
    if [[ -f "$flake" ]] && has_custom_modifications "$flake"; then
        if [[ "$force" != "true" ]]; then
            warn "flake.nix has modifications outside nixy markers."
            warn "Use --force to proceed (custom changes will be lost)."
            die "Aborted. Use 'nixy install --file $file --force' to override."
        fi
        warn "Proceeding with --force: custom modifications outside markers will be lost."
    fi

    # Create packages directory inside flake directory
    local pkg_dir
    pkg_dir=$(get_packages_dir "$flake_dir")
    mkdir -p "$pkg_dir"

    # Copy file to packages directory
    local dest="$pkg_dir/$pkg_name.nix"
    cp "$file" "$dest"
    success "Copied package definition to $dest"

    # Add the package file to git if the flake directory is a git repo
    if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
        git -C "$flake_dir" add "packages/$pkg_name.nix" 2>/dev/null || true
    fi

    # Regenerate flake.nix preserving existing packages and custom content
    # Write to temp file first to avoid truncating source before reading
    local -a packages=()
    while IFS= read -r p; do
        [[ -n "$p" ]] && packages+=("$p")
    done < <(get_packages_from_flake "$flake")

    local tmp_flake
    tmp_flake=$(mktemp)
    generate_flake --flake-dir "$flake_dir" --preserve-from "$flake" "${packages[@]+"${packages[@]}"}" > "$tmp_flake"
    command mv "$tmp_flake" "$flake"

    info "Installing $pkg_name..."
    cmd_sync
}

# Install a package from a local flake file
cmd_install_from_flake_file() {
    local file="$1"
    local force="${2:-false}"

    # Extract package name from filename (remove .nix extension and path)
    local pkg_name
    pkg_name=$(basename "$file" .nix)
    # Sanitize: replace non-alphanumeric chars with dashes
    pkg_name=$(echo "$pkg_name" | tr -cs 'a-zA-Z0-9-' '-' | sed 's/^-//;s/-$//')
    [[ -z "$pkg_name" ]] && die "Could not determine package name from filename: $file"

    info "Installing local flake: $pkg_name from $file"

    # Get flake directory first (packages must be relative to flake for git tracking)
    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    # Check for custom modifications outside markers BEFORE making any changes
    if [[ -f "$flake" ]] && has_custom_modifications "$flake"; then
        if [[ "$force" != "true" ]]; then
            warn "flake.nix has modifications outside nixy markers."
            warn "Use --force to proceed (custom changes will be lost)."
            die "Aborted. Use 'nixy install --file $file --force' to override."
        fi
        warn "Proceeding with --force: custom modifications outside markers will be lost."
    fi

    # Create packages/pkg_name directory for the flake (nix requires flakes to be in a directory)
    local pkg_dir
    pkg_dir=$(get_packages_dir "$flake_dir")
    local flake_pkg_dir="$pkg_dir/$pkg_name"
    mkdir -p "$flake_pkg_dir"

    # Copy file as flake.nix inside the package directory
    local dest="$flake_pkg_dir/flake.nix"
    cp "$file" "$dest"
    success "Copied flake to $dest"

    # Add the flake file to git if the flake directory is a git repo
    if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
        git -C "$flake_dir" add "packages/$pkg_name/flake.nix" 2>/dev/null || true
    fi

    # Regenerate flake.nix preserving existing packages and custom content
    # Write to temp file first to avoid truncating source before reading
    local -a packages=()
    while IFS= read -r p; do
        [[ -n "$p" ]] && packages+=("$p")
    done < <(get_packages_from_flake "$flake")

    local tmp_flake
    tmp_flake=$(mktemp)
    generate_flake --flake-dir "$flake_dir" --preserve-from "$flake" "${packages[@]+"${packages[@]}"}" > "$tmp_flake"
    command mv "$tmp_flake" "$flake"

    info "Installing $pkg_name..."
    cmd_sync
}

# Uninstall a package
cmd_uninstall() {
    local pkg=""

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*) die "Unknown option: $1" ;;
            *) pkg="$1"; shift ;;
        esac
    done

    [[ -z "$pkg" ]] && die "Usage: nixy uninstall <package>"

    # Check if existing flake.nix is nixy-managed before uninstalling
    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    info "Uninstalling $pkg..."

    # Remove local package file or flake directory (if exists)
    local pkg_dir
    pkg_dir=$(get_packages_dir "$flake_dir")
    local local_pkg_file="$pkg_dir/$pkg.nix"
    local local_flake_dir="$pkg_dir/$pkg"
    if [[ -f "$local_pkg_file" ]]; then
        info "Removing local package definition: $local_pkg_file"
        rm "$local_pkg_file"
        if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
            git -C "$flake_dir" rm --cached "packages/$pkg.nix" 2>/dev/null || true
        fi
    elif [[ -d "$local_flake_dir" && -f "$local_flake_dir/flake.nix" ]]; then
        info "Removing local flake: $local_flake_dir"
        rm -rf "$local_flake_dir"
        if [[ -d "$flake_dir/.git" ]] || git -C "$flake_dir" rev-parse --git-dir >/dev/null 2>&1; then
            git -C "$flake_dir" rm -r --cached "packages/$pkg" 2>/dev/null || true
        fi
    fi

    # Remove from flake.nix (source of truth)
    remove_package_from_flake "$pkg"

    info "Rebuilding environment..."
    cmd_sync
}

# Search for packages
cmd_search() {
    local query="$1"
    [[ -z "$query" ]] && die "Usage: nixy search <query>"

    info "Searching for $query..."
    nix "${NIX_FLAGS[@]}" search nixpkgs "$query"
}

# List installed packages (from flake.nix)
cmd_list() {
    local flake
    flake=$(get_flake) || exit 1

    if [[ ! -f "$flake" ]]; then
        die "No flake.nix found at $flake. Run 'nixy install <package>' to create one."
    fi

    info "Packages in $flake:"
    local packages
    packages=$(get_packages_from_flake "$flake")
    if [[ -z "$packages" ]]; then
        echo "  (none)"
    else
        echo "$packages" | while read -r pkg; do
            echo "  $pkg"
        done
    fi
}

# Upgrade all packages or specific inputs
cmd_upgrade() {
    local -a inputs=()

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                echo "Usage: nixy upgrade [input...]"
                echo ""
                echo "Upgrade all flake inputs or specific ones."
                echo ""
                echo "Arguments:"
                echo "  input...    Specific input(s) to upgrade (e.g., nixpkgs)"
                echo ""
                echo "Examples:"
                echo "  nixy upgrade              # Upgrade all inputs"
                echo "  nixy upgrade nixpkgs      # Upgrade only nixpkgs"
                echo "  nixy upgrade nixpkgs foo  # Upgrade multiple inputs"
                return 0
                ;;
            --*) die "Unknown option: $1" ;;
            *) inputs+=("$1"); shift ;;
        esac
    done

    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"
    local lock_file="$flake_dir/flake.lock"

    if [[ ! -f "$flake" ]]; then
        die "No flake.nix found at $flake. Run 'nixy install <package>' to create one."
    fi

    # If specific inputs are requested, validate them
    if [[ ${#inputs[@]} -gt 0 ]]; then
        if [[ ! -f "$lock_file" ]]; then
            die "No flake.lock found. Run 'nixy sync' first."
        fi

        # First check if we can parse the lock file
        local available
        if ! available=$(get_flake_inputs "$lock_file" | tr '\n' ' '); then
            die "Failed to parse flake.lock. The file may be corrupted."
        fi

        if ! validate_flake_inputs "$lock_file" "${inputs[@]}"; then
            error "Unknown input(s): ${INVALID_INPUTS[*]}"
            die "Available inputs: $available"
        fi

        info "Updating inputs: ${inputs[*]}..."
        nix "${NIX_FLAGS[@]}" flake update "${inputs[@]}" --flake "$flake_dir"
    else
        info "Updating all inputs..."
        nix "${NIX_FLAGS[@]}" flake update --flake "$flake_dir"
    fi

    info "Rebuilding environment..."
    mkdir -p "$(dirname "$NIXY_ENV")"
    nix "${NIX_FLAGS[@]}" build "$flake_dir#default" --out-link "$NIXY_ENV" || \
        die "Failed to rebuild environment"

    if [[ ${#inputs[@]} -gt 0 ]]; then
        success "Upgraded: ${inputs[*]}"
    else
        success "All inputs upgraded"
    fi
}

# Garbage collect old generations
cmd_gc() {
    info "Running garbage collection..."
    nix-collect-garbage -d
    success "Garbage collection complete"
}

# Get packages directory for a given flake directory
get_packages_dir() {
    local flake_dir="$1"
    echo "$flake_dir/packages"
}

# Collect local packages info
# Sets arrays: LOCAL_PKG_NAMES, LOCAL_PKG_INPUTS, LOCAL_PKG_OVERLAYS, LOCAL_PKG_EXPRS
# Also sets: LOCAL_FLAKE_NAMES (for flake-type packages in subdirectories)
# Takes optional packages_dir argument (defaults to LOCAL_PACKAGES_DIR for backwards compat)
collect_local_packages() {
    local packages_dir="${1:-$LOCAL_PACKAGES_DIR}"
    LOCAL_PKG_NAMES=()
    LOCAL_PKG_INPUTS=()
    LOCAL_PKG_OVERLAYS=()
    LOCAL_PKG_EXPRS=()
    LOCAL_FLAKE_NAMES=()

    [[ ! -d "$packages_dir" ]] && return

    # First, scan for flake directories (subdirectories with flake.nix)
    for flake_dir in "$packages_dir"/*/; do
        [[ ! -d "$flake_dir" ]] && continue
        local flake_file="$flake_dir/flake.nix"
        [[ ! -f "$flake_file" ]] && continue

        # Get the directory name as the package name
        local name
        name=$(basename "$flake_dir")
        LOCAL_FLAKE_NAMES+=("$name")
    done

    # Then, scan for regular .nix files
    for pkg_file in "$packages_dir"/*.nix; do
        [[ ! -f "$pkg_file" ]] && continue

        local name input_name input_url overlay pkg_expr

        # Try 'pname' first (nixpkgs standard), then fall back to 'name'
        name=$(parse_local_package "$pkg_file" "pname")
        [[ -z "$name" ]] && name=$(parse_local_package "$pkg_file" "name")
        [[ -z "$name" ]] && continue

        # Parse inputs block - extract input name and url (handles multiline)
        # Format: inputs = { \n  name.url = "url"; \n };
        # Look for lines containing .url = within the inputs block
        input_name=$(grep '\.url[[:space:]]*=' "$pkg_file" 2>/dev/null | head -1 | sed 's/^[[:space:]]*\([a-zA-Z0-9_-]*\)\.url.*/\1/' || true)
        input_url=$(grep '\.url[[:space:]]*=' "$pkg_file" 2>/dev/null | head -1 | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/' || true)

        overlay=$(parse_local_package "$pkg_file" "overlay")
        pkg_expr=$(parse_local_package "$pkg_file" "packageExpr")

        # If no packageExpr, assume nixpkgs-style derivation and use callPackage
        if [[ -z "$pkg_expr" ]]; then
            pkg_expr="pkgs.callPackage ./packages/$name.nix {}"
        fi

        LOCAL_PKG_NAMES+=("$name")
        LOCAL_PKG_INPUTS+=("$input_name|$input_url")
        LOCAL_PKG_OVERLAYS+=("$overlay")
        LOCAL_PKG_EXPRS+=("$pkg_expr")
    done
}

# Generate flake.nix content
# Usage: generate_flake [--flake-dir <dir>] [--preserve-from <flake>] [package1] [package2] ...
generate_flake() {
    local flake_dir=""
    local preserve_from=""
    local -a packages=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --flake-dir)
                flake_dir="$2"
                shift 2
                ;;
            --preserve-from)
                preserve_from="$2"
                shift 2
                ;;
            *)
                packages+=("$1")
                shift
                ;;
        esac
    done

    # Extract custom content from existing flake if specified
    # Add trailing newline to non-empty content for proper formatting in heredoc
    local custom_inputs=""
    local custom_packages=""
    local custom_paths=""
    if [[ -n "$preserve_from" && -f "$preserve_from" ]]; then
        custom_inputs=$(extract_marker_content "$preserve_from" "nixy:custom-inputs")
        custom_packages=$(extract_marker_content "$preserve_from" "nixy:custom-packages")
        custom_paths=$(extract_marker_content "$preserve_from" "nixy:custom-paths")
        # Ensure trailing newline for proper heredoc formatting
        [[ -n "$custom_inputs" ]] && custom_inputs="$custom_inputs"$'\n'
        [[ -n "$custom_packages" ]] && custom_packages="$custom_packages"$'\n'
        [[ -n "$custom_paths" ]] && custom_paths="$custom_paths"$'\n'
    fi

    local pkg_entries=""

    # Determine packages directory
    local packages_dir=""
    if [[ -n "$flake_dir" ]]; then
        packages_dir=$(get_packages_dir "$flake_dir")
    fi

    # Filter out local packages (including flake packages) from standard packages list
    if [[ -n "$packages_dir" ]]; then
        collect_local_packages "$packages_dir"
    else
        LOCAL_PKG_NAMES=()
        LOCAL_FLAKE_NAMES=()
    fi
    local -a filtered_packages=()
    for pkg in "${packages[@]+"${packages[@]}"}"; do
        [[ -z "$pkg" ]] && continue
        local is_local=false
        # Check against regular local packages
        for local_name in "${LOCAL_PKG_NAMES[@]+"${LOCAL_PKG_NAMES[@]}"}"; do
            if [[ "$pkg" == "$local_name" ]]; then
                is_local=true
                break
            fi
        done
        # Check against flake packages
        if [[ "$is_local" == "false" ]]; then
            for flake_name in "${LOCAL_FLAKE_NAMES[@]+"${LOCAL_FLAKE_NAMES[@]}"}"; do
                if [[ "$pkg" == "$flake_name" ]]; then
                    is_local=true
                    break
                fi
            done
        fi
        if [[ "$is_local" == "false" ]]; then
            filtered_packages+=("$pkg")
        fi
    done

    for pkg in "${filtered_packages[@]+"${filtered_packages[@]}"}"; do
        [[ -z "$pkg" ]] && continue
        pkg_entries+="          $pkg = pkgs.$pkg;"$'\n'
    done

    # Build local inputs section
    local local_inputs=""
    local local_input_params=""
    local local_overlays=""
    local local_packages=""

    # Handle flake-type packages (subdirectories with flake.nix)
    if [[ ${#LOCAL_FLAKE_NAMES[@]} -gt 0 ]]; then
        for name in "${LOCAL_FLAKE_NAMES[@]}"; do
            local_inputs+="    $name.url = \"path:./packages/$name\";"$'\n'
            local_input_params+="$name, "
            # Use inputs.$name to avoid shadowing in rec block
            local_packages+="          $name = inputs.$name.packages.\${system}.default;"$'\n'
        done
    fi

    # Handle regular local packages (.nix files)
    if [[ ${#LOCAL_PKG_NAMES[@]} -gt 0 ]]; then
        for i in "${!LOCAL_PKG_NAMES[@]}"; do
            local name="${LOCAL_PKG_NAMES[$i]}"
            local input_info="${LOCAL_PKG_INPUTS[$i]}"
            local overlay="${LOCAL_PKG_OVERLAYS[$i]}"
            local pkg_expr="${LOCAL_PKG_EXPRS[$i]}"

            local input_name="${input_info%%|*}"
            local input_url="${input_info##*|}"

            if [[ -n "$input_name" && -n "$input_url" ]]; then
                local_inputs+="    $input_name.url = \"$input_url\";"$'\n'
                local_input_params+="$input_name, "
            fi

            if [[ -n "$overlay" ]]; then
                local_overlays+="          $overlay"$'\n'
            fi

            if [[ -n "$pkg_expr" ]]; then
                local_packages+="          $name = $pkg_expr;"$'\n'
            fi
        done
    fi

    # Build buildEnv paths array (for atomic install)
    # Use package names to reference attributes in the rec set
    local buildenv_paths=""
    for pkg in "${filtered_packages[@]+"${filtered_packages[@]}"}"; do
        [[ -z "$pkg" ]] && continue
        buildenv_paths+="              $pkg"$'\n'
    done

    # Add local package names to buildenv paths (reference by name, not expression)
    if [[ ${#LOCAL_PKG_NAMES[@]} -gt 0 ]]; then
        for name in "${LOCAL_PKG_NAMES[@]}"; do
            buildenv_paths+="              $name"$'\n'
        done
    fi

    # Add flake-type package names to buildenv paths
    if [[ ${#LOCAL_FLAKE_NAMES[@]} -gt 0 ]]; then
        for name in "${LOCAL_FLAKE_NAMES[@]}"; do
            buildenv_paths+="              $name"$'\n'
        done
    fi

    # Build outputs function parameters
    local output_params="self, nixpkgs"
    if [[ -n "$local_input_params" ]]; then
        output_params="self, nixpkgs, ${local_input_params%, }"
    fi

    # Build overlays array
    local overlays_content=""
    if [[ -n "$local_overlays" ]]; then
        overlays_content="overlays = [
          # [nixy:local-overlays]
${local_overlays}          # [/nixy:local-overlays]
        ];"
    fi

    # Determine pkgs definition based on whether we have overlays
    local pkgs_def
    if [[ -n "$local_overlays" ]]; then
        pkgs_def="pkgsFor = system: import nixpkgs {
        inherit system;
        $overlays_content
      };
"
    else
        pkgs_def=""
    fi

    local pkgs_binding
    if [[ -n "$local_overlays" ]]; then
        pkgs_binding="let pkgs = pkgsFor system;"
    else
        pkgs_binding="let pkgs = nixpkgs.legacyPackages.\${system};"
    fi

    cat << EOF
{
  description = "nixy managed packages";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    # [nixy:local-inputs]
${local_inputs}    # [/nixy:local-inputs]
    # [nixy:custom-inputs]
${custom_inputs}    # [/nixy:custom-inputs]
  };

  outputs = { $output_params }@inputs:
    let
      systems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
      forAllSystems = f: nixpkgs.lib.genAttrs systems (system: f system);
      $pkgs_def
    in {
      # Profile packages (nixy install)
      packages = forAllSystems (system:
        $pkgs_binding
        in rec {
          # [nixy:packages]
${pkg_entries}          # [/nixy:packages]
          # [nixy:local-packages]
${local_packages}          # [/nixy:local-packages]
          # [nixy:custom-packages]
${custom_packages}          # [/nixy:custom-packages]

          # Unified environment for atomic install (nixy sync)
          default = pkgs.buildEnv {
            name = "nixy-env";
            paths = [
              # [nixy:env-paths]
${buildenv_paths}              # [/nixy:env-paths]
              # [nixy:custom-paths]
${custom_paths}              # [/nixy:custom-paths]
            ];
            extraOutputsToInstall = [ "man" "doc" "info" ];
          };
        });
    };
}
EOF
}

# Sync installed packages with flake.nix (using nix build --out-link)
cmd_sync() {
    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --remove|-r) shift ;; # Kept for backward compatibility (no-op)
            -*) die "Unknown option: $1" ;;
            *) shift ;;
        esac
    done

    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"

    if [[ ! -f "$flake" ]]; then
        die "No flake.nix found at $flake. Run 'nixy install <package>' to create one."
    fi

    info "Syncing packages with $flake..."

    # Check if flake has buildEnv default output (upgrade from old nixy version)
    if ! nix "${NIX_FLAGS[@]}" eval "$flake_dir#default" &>/dev/null; then
        info "Upgrading flake.nix to buildEnv format..."
        local -a packages=()
        while IFS= read -r p; do
            [[ -n "$p" ]] && packages+=("$p")
        done < <(get_packages_from_flake "$flake")
        # Write to temp file first to avoid truncating source before reading
        local tmp_flake
        tmp_flake=$(mktemp)
        generate_flake --flake-dir "$flake_dir" --preserve-from "$flake" "${packages[@]+"${packages[@]}"}" > "$tmp_flake"
        command mv "$tmp_flake" "$flake"
    fi

    # Build environment and create symlink
    info "Building nixy environment..."
    mkdir -p "$(dirname "$NIXY_ENV")"
    nix "${NIX_FLAGS[@]}" build "$flake_dir#default" --out-link "$NIXY_ENV" || \
        die "Failed to build environment"

    success "Sync complete"
}

# Add a package to flake.nix (partial edit to preserve user customizations)
add_package_to_flake() {
    local pkg="$1"
    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    # If flake doesn't exist, create it with generate_flake
    if [[ ! -f "$flake" ]]; then
        mkdir -p "$flake_dir"
        generate_flake --flake-dir "$flake_dir" "$pkg" > "$flake"
        success "Added $pkg to $flake"
        return 0
    fi

    # Check if package already exists in flake (use direct grep, works without flake.lock)
    if grep -q "^[[:space:]]*$pkg = pkgs\\.$pkg;" "$flake"; then
        success "Package $pkg already in $flake"
        return 0
    fi

    # Partial edit: insert package into existing flake.nix
    # 1. Add to packages section: "          $pkg = pkgs.$pkg;"
    insert_after_marker "$flake" "# \[nixy:packages\]" "          $pkg = pkgs.$pkg;"

    # 2. Add to env-paths section: "              $pkg"
    insert_after_marker "$flake" "# \[nixy:env-paths\]" "              $pkg"

    success "Added $pkg to $flake"
}

# Remove a package from flake.nix (partial edit to preserve user customizations)
remove_package_from_flake() {
    local pkg="$1"
    local flake_dir
    flake_dir=$(get_flake_dir) || exit 1
    local flake="$flake_dir/flake.nix"

    # Check if existing flake.nix is nixy-managed
    if [[ -f "$flake" ]] && ! is_nixy_managed_flake "$flake"; then
        die "Existing flake.nix is not managed by nixy."
    fi

    if [[ ! -f "$flake" ]]; then
        die "No flake.nix found at $flake"
    fi

    # Partial edit: remove package from existing flake.nix
    # Markers use literal strings (matched with index()), patterns use regex
    # 1. Remove from packages section: "$pkg = pkgs.$pkg;"
    remove_line_from_section "$flake" '# [nixy:packages]' '# [/nixy:packages]' "^[[:space:]]*$pkg = pkgs\\\\.$pkg;"

    # 2. Remove from env-paths section: "$pkg" (exact match with whitespace)
    remove_line_from_section "$flake" '# [nixy:env-paths]' '# [/nixy:env-paths]' "^[[:space:]]*$pkg\$"

    success "Removed $pkg from $flake"
}

# Self-upgrade nixy to latest version
cmd_self_upgrade() {
    local force=false
    local dry_run=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            --dry-run) dry_run=true; shift ;;
            *) die "Unknown option: $1. Usage: nixy self-upgrade [--force]" ;;
        esac
    done

    # Dry run mode - just validate args and exit
    if [[ "$dry_run" == "true" ]]; then
        return 0
    fi

    # Get the path to the current script
    local self_path
    self_path="$(realpath "${BASH_SOURCE[0]}")"
    local self_dir
    self_dir="$(dirname "$self_path")"

    # Check write permissions
    if [[ ! -w "$self_dir" ]]; then
        die "No write permission to $self_dir. Try: sudo nixy self-upgrade"
    fi

    info "Checking for updates..."

    # Download latest version to temp file
    local tmp_file
    tmp_file="$(mktemp)"
    trap 'rm -f "$tmp_file"' EXIT

    if ! curl -fsSL "$NIXY_REPO_URL" -o "$tmp_file" 2>/dev/null; then
        die "Failed to download latest version. Check your network connection."
    fi

    # Validate downloaded file (check shebang)
    local first_line
    first_line="$(head -n 1 "$tmp_file")"
    if [[ "$first_line" != "#!/usr/bin/env bash" ]]; then
        die "Downloaded file is invalid (unexpected content)"
    fi

    # Extract remote version
    local remote_version
    remote_version="$(grep -E '^NIXY_VERSION=' "$tmp_file" | head -1 | sed 's/NIXY_VERSION="\([^"]*\)"/\1/')"
    if [[ -z "$remote_version" ]]; then
        die "Could not determine remote version"
    fi

    info "Current version: $NIXY_VERSION"
    info "Latest version:  $remote_version"

    # Compare versions
    if [[ "$NIXY_VERSION" == "$remote_version" ]] && [[ "$force" != "true" ]]; then
        success "Already up to date!"
        rm -f "$tmp_file"
        trap - EXIT
        return 0
    fi

    if [[ "$force" == "true" ]] && [[ "$NIXY_VERSION" == "$remote_version" ]]; then
        info "Forcing reinstall of same version..."
    fi

    # Create backup
    local backup_path="${self_path}.backup"
    info "Creating backup at $backup_path..."
    cp "$self_path" "$backup_path"

    # Get current permissions
    local perms
    perms="$(stat -f '%A' "$self_path" 2>/dev/null || stat -c '%a' "$self_path" 2>/dev/null)"

    # Replace executable
    if ! command mv "$tmp_file" "$self_path"; then
        error "Failed to update nixy"
        info "Restoring from backup..."
        command mv "$backup_path" "$self_path"
        die "Update failed. Original version restored."
    fi

    # Restore permissions
    chmod "$perms" "$self_path"

    # Clean up backup on success
    rm -f "$backup_path"

    # Clear the trap since tmp_file was moved, not deleted
    trap - EXIT

    success "Successfully upgraded to version $remote_version!"
}

# Output shell configuration for eval
cmd_config() {
    local shell="${1:-}"

    case "$shell" in
        bash|zsh|sh)
            cat << 'EOF'
# nixy shell configuration
export PATH="$HOME/.local/state/nixy/env/bin:$PATH"
EOF
            ;;
        fish)
            cat << 'EOF'
# nixy shell configuration
set -gx PATH $HOME/.local/state/nixy/env/bin $PATH
EOF
            ;;
        "")
            die "Usage: nixy config <shell>
Supported shells: bash, zsh, fish

Add to your shell config:
  bash/zsh: eval \"\$(nixy config zsh)\"
  fish:     nixy config fish | source"
            ;;
        *)
            die "Unknown shell: $shell. Supported: bash, zsh, fish"
            ;;
    esac
}

# Show version
cmd_version() {
    echo "nixy version $NIXY_VERSION"
}

# Profile management commands
cmd_profile() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        switch|use)
            cmd_profile_switch "$@"
            ;;
        list|ls)
            cmd_profile_list "$@"
            ;;
        delete|rm)
            cmd_profile_delete "$@"
            ;;
        "")
            # No subcommand: show current profile
            local active
            active=$(get_active_profile)
            info "Active profile: $active"
            ;;
        *)
            die "Unknown profile subcommand: $subcmd. Run 'nixy help' for usage."
            ;;
    esac
}

cmd_profile_switch() {
    local name=""
    local create=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--create) create=true; shift ;;
            -*)
                die "Unknown option: $1. Usage: nixy profile switch [-c] <name>"
                ;;
            *)
                [[ -z "$name" ]] && name="$1"
                shift
                ;;
        esac
    done

    [[ -z "$name" ]] && die "Usage: nixy profile switch [-c] <name>"

    validate_profile_name "$name"

    local profile_dir
    profile_dir=$(get_profile_dir "$name")

    # Auto-create default profile from legacy location if needed
    if [[ "$name" == "$NIXY_DEFAULT_PROFILE" ]] && [[ ! -d "$profile_dir" ]]; then
        if [[ -f "$GLOBAL_FLAKE" ]]; then
            info "Migrating legacy flake to default profile..."
            mkdir -p "$profile_dir"
            cp "$GLOBAL_FLAKE" "$profile_dir/flake.nix"
            [[ -f "$NIXY_CONFIG_DIR/flake.lock" ]] && cp "$NIXY_CONFIG_DIR/flake.lock" "$profile_dir/flake.lock"
            [[ -d "$LOCAL_PACKAGES_DIR" ]] && cp -r "$LOCAL_PACKAGES_DIR" "$profile_dir/packages"
        fi
    fi

    # Create profile if -c flag is set and profile doesn't exist
    if [[ ! -d "$profile_dir" ]]; then
        if [[ "$create" == "true" ]]; then
            info "Creating profile '$name'..."
            mkdir -p "$profile_dir"
            generate_flake --flake-dir "$profile_dir" > "$profile_dir/flake.nix"
        else
            die "Profile '$name' does not exist. Use -c to create it: nixy profile switch -c $name"
        fi
    fi

    info "Switching to profile '$name'..."
    set_active_profile "$name"

    # Rebuild environment for the new profile
    if [[ -f "$profile_dir/flake.nix" ]]; then
        info "Building environment for profile '$name'..."
        mkdir -p "$(dirname "$NIXY_ENV")"
        if nix "${NIX_FLAGS[@]}" build "$profile_dir#default" --out-link "$NIXY_ENV" 2>/dev/null; then
            success "Switched to profile '$name'"
        else
            warn "Profile switched but environment build failed. Run 'nixy sync' to rebuild."
            success "Switched to profile '$name'"
        fi
    else
        success "Switched to profile '$name' (no packages installed)"
    fi
}

cmd_profile_list() {
    local active
    active=$(get_active_profile)

    info "Available profiles:"

    # Check for legacy flake (not yet migrated)
    local has_profiles=false

    if [[ -d "$NIXY_PROFILES_DIR" ]]; then
        for profile_dir in "$NIXY_PROFILES_DIR"/*/; do
            [[ ! -d "$profile_dir" ]] && continue
            has_profiles=true
            local name
            name=$(basename "$profile_dir")
            if [[ "$name" == "$active" ]]; then
                echo "  * $name (active)"
            else
                echo "    $name"
            fi
        done
    fi

    # Show legacy location if exists and no profiles yet
    if [[ "$has_profiles" == "false" ]]; then
        if [[ -f "$GLOBAL_FLAKE" ]]; then
            echo "  * default (active, legacy location)"
            echo ""
            info "Run 'nixy profile switch default' to migrate to the new profile structure."
        else
            echo "  (no profiles)"
            echo ""
            info "Create a profile with: nixy profile switch -c <name>"
        fi
    fi
}

cmd_profile_delete() {
    local name=""
    local force=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            -*)
                die "Unknown option: $1. Usage: nixy profile delete [--force] <name>"
                ;;
            *)
                [[ -z "$name" ]] && name="$1"
                shift
                ;;
        esac
    done

    [[ -z "$name" ]] && die "Usage: nixy profile delete [--force] <name>"

    validate_profile_name "$name"

    local profile_dir
    profile_dir=$(get_profile_dir "$name")

    if [[ ! -d "$profile_dir" ]]; then
        die "Profile '$name' does not exist"
    fi

    local active
    active=$(get_active_profile)

    if [[ "$name" == "$active" ]]; then
        die "Cannot delete the active profile. Switch to another profile first."
    fi

    if [[ "$force" != "true" ]]; then
        warn "This will delete profile '$name' and all its packages."
        die "Use --force to confirm deletion."
    fi

    info "Deleting profile '$name'..."
    rm -rf "$profile_dir"
    success "Deleted profile '$name'"
}

# Show help
cmd_help() {
    cat << 'EOF'
nixy - Homebrew-style wrapper for Nix (using flake.nix)

USAGE:
    nixy <command> [args]

BASIC COMMANDS:
    install <pkg>           Install a package
    install --file <path>   Install from local nix file
    uninstall <pkg>         Uninstall a package
    search <query>          Search for packages
    list                    List packages in flake.nix
    upgrade [input...]      Upgrade all inputs or specific ones
    version                 Show nixy version

PROFILE COMMANDS:
    profile                 Show current profile
    profile switch <name>   Switch to a different profile (-c to create)
    profile list            List all profiles
    profile delete <name>   Delete a profile (--force required)

SYNC COMMANDS:
    sync                    Build environment from flake.nix and create symlink
                            (use on new machine to restore packages)

MAINTENANCE COMMANDS:
    gc                      Garbage collect old generations
    self-upgrade [--force]  Upgrade nixy to the latest version
    config <shell>          Output shell config (for eval in rc files)

FLAGS:
    --force                 Force regeneration even if flake.nix has
                            custom modifications outside markers

CONFIG FILES:
    Profiles: ~/.config/nixy/profiles/<name>/flake.nix
    Active profile: ~/.config/nixy/active
    Environment symlink: ~/.local/state/nixy/env
    Legacy (auto-migrated): ~/.config/nixy/flake.nix, ~/.config/nixy/packages/

PATH SETUP:
    Add to your shell config:
      bash/zsh: eval "$(nixy config zsh)"
      fish:     nixy config fish | source

LOCAL PACKAGE FORMAT:
    {
      name = "my-package";
      inputs = { overlay-name.url = "github:user/repo"; };
      overlay = "overlay-name.overlays.default";
      packageExpr = "pkgs.my-package";
    }

EXAMPLES:
    nixy install ripgrep                # Install a package
    nixy uninstall ripgrep              # Remove from flake.nix
    nixy install --file neovim.nix      # Install from local nix file
    nixy sync                           # Build/restore environment
    nixy upgrade                        # Update nixpkgs and rebuild
    nixy version                        # Show current version
    nixy self-upgrade                   # Upgrade to latest version
    nixy profile switch -c work         # Create and switch to 'work' profile
    nixy profile switch work            # Switch to existing 'work' profile
    nixy profile list                   # List all profiles

EOF
}

# Main entry point
main() {
    check_deps

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        install|add)
            cmd_install "$@"
            ;;
        uninstall|remove)
            cmd_uninstall "$@"
            ;;
        search)
            cmd_search "${1:-}"
            ;;
        list|ls)
            cmd_list
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        gc)
            cmd_gc
            ;;
        sync)
            cmd_sync "$@"
            ;;
        self-upgrade)
            cmd_self_upgrade "$@"
            ;;
        config)
            cmd_config "${1:-}"
            ;;
        profile)
            cmd_profile "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            die "Unknown command: $cmd. Run 'nixy help' for usage."
            ;;
    esac
}

# Only run main if this script is being executed, not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
